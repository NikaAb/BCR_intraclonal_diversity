<br><br>
<h3 id="titleAnalysis"></h3>
<br><br>
<!-- Container of the representation -->
<div style="width: 100%; height: 100%;">
  <!-- Chart1 : contain the zooming circle packing representation -->
  <div style="width: 50%; height: 70%; float: left;" id="chart1"></div>
  <!-- Chart2 : contain the elements needed to observed the clonality threshold -->
  <div id="chart2" style="margin-left: 50%; height: 70%;" >
    <!-- Button that appears when clicking on a specific clone --> 
    <div id="nextButton"><input type="button" onclick="window.location='clonotype.php';" value="Intraclonal study" /></div>
    <!-- Contain the bar chart representation -->
    <div id="barChart" style="width: 100%; height: 70%;"></div>
    <!-- Contain the tree representation -->
    <div id="clonotypeTree" style="width: 100%; height: 70%;"></div>
    <!-- Contain the form which allow to change the value of clonality threshold -->
    <div id="thresholdSelection" style="width: 100%; height: 10%;">
      <form class="thresholdForm" name="thresholdForm">
        <div>
          <div style="float : left;">
            <label class="thresholdLabel" for="threshold">Clonality treshold (%) : </label>
            <input type="text" name="threshold" style="width: 30px;"/>
          </div>
          <input class="enterButton" type="button" name="enterButton" value="Enter" onclick="changeThreshold()" style="width:80px" />
        </div>
      </form>
    </div>
  </div><br>
  <!-- Button to change the tree form --> 
  <div id="treeForm" style="margin-left: 55%; ">
    <div><input type="radio" name="treeForm" id="circleTree" onClick="changeTree(this.value);" value=0>
    <label for="circleTree">Circular tree</label></div>
    <div><input type="radio" name="treeForm" id="elbowTree" onClick="changeTree(this.value);" value=1>
    <label for="elbowTree">Elbow tree</label></div>
  </div>
  <div id="checkboxProductivity">
    <input type="checkbox" id="productivity" name="productivity" onClick="displayTree();">
    <label for="productivity">Productivity (green productive)</label>
  </div><br><br>
  <!-- Chart3 : show abundance, V and J sequences and cdr3 regions -->
  <div id="chart3" style="width: 100%; height: 30%; " >
    <table id="cloneTable"></table>
    <a id="downloadButton" style="float: right; margin-right: 10%; ">
      <button type="button" onclick="downloadClonesInformations()">Download</button>
    </a>
  </div>
</div>

<script>
/* This script allows the visualization of the repertoire from data supplied by the user. There is thus a number of visualizations in order to represent this repertoire : 
	- zooming circle packing to observe the abundance of clones and clonotypes
	- bar chart to observe the clonality threshold
	- an area allowing to select the clones of interest for further analysis
	- an area where the sequences V, J and cdr3 regions can be observed */

// ************************************************************************************

//title of the page :
titleAnalysis.innerText = "<?php echo $title; ?>";

var yMax = 0;
var threshold = -1;
var firstCreation = true;
var objectSelected;
var form = 0;

function changeThreshold(){ 
  threshold = parseFloat(document.thresholdForm.threshold.value);
  if(threshold){
    var height = (document.getElementById('barChart').offsetHeight/1.25) - 70;
    const y = d3.scaleLinear()
             .range([height, 0]);
    y.domain([0, yMax])

    var svg2 = d3.select("#barChart svg");
    svg2.selectAll(".thresholdLine")
             .attr("y1", y(threshold))
             .attr("y2", y(threshold));
  }else{
    alert("Please enter a percentage");
  }
}

function changeTree(typeTree){
  form = typeTree;
  displayTree();
}

// *********************************** Zooming circle packing visualization of the repertoire ***************************************

//selection of svg
var svg1 = d3.select("#chart1").append("svg")
             .attr("width", "100%")
             .attr("height", "100%"),
    diameter = Math.min(document.getElementById('chart1').offsetWidth, document.getElementById('chart1').offsetHeight),
    g = svg1.append("g").attr("transform", "translate(" + diameter / 2 + "," + diameter / 2 + ")"); /* set the size of the */

//creation of pack layout
var packLayout = d3.pack()
              .size([(diameter), (diameter)])
              .padding(6);//padding around each circle

//declare a new local variable scoped by the DOM
var local = d3.local();

var user = "<?php echo $userFile; ?>",
    file = user +"_repertoire_two_levels_info.json";
    path = "pipeline/usersFiles/"+user+"/GTM/"+file;

//loading the json file
d3.json(path, function(error, data) {
  if (error) throw error;

  //separate the data in two: the parents containing the clones and the children containing the clonotypes. This then makes it possible in the representation to keep the proportions between the clones regardless of the number of clonotypes they contain.
  var children = [],
  parent = parseClone(data, children);
  objectSelected = children; //store the clone or clonotype depending on the zoom we have done to allow to download the data

  //parent pack to represente the clone
  root = d3.hierarchy(parent)
      .sum(function(d) { return d.value; });

  //store the root in focus variable to allow zoom
  var focus = root, view, cloneZoom = false, child;

  //create the parent circle pack from the parent pack, add a g container for each clone
  var parentNodes = g.selectAll("g")
                 .data(packLayout(root).descendants())
                 .enter().append("g")
      
  //create circle on each g container of the clones and add style to this circle	
  parentNodes.append("circle")
             .attr("r", function(d) { return d.r; })
             .style("opacity", 0.7)
             .style("stroke-width", 2)
             .style("fill", function(d){ return d.data.color; })
             .style("stroke", function(d){ return d.data.stroke; })
             .style("stroke-dasharray", function(d){ return d.data.style; })
             .on("click", function(d,i) { if(d3.select(child)._groups[0][0]){d3.select(child)._groups[0][0].remove();} 
                                          if (focus !== d && children[i-1].children) {
                                            child = displayClonotype(d,i);
                                            cloneZoom=true;
                                            zoom(d), d3.event.stopPropagation();
                                            objectSelected = children[i-1].children;
                                            form=0;
                                            clonePage(children[i-1].children,d.data.name);} 
                          });

  //add name of the clone on the circle
  parentNodes.append("text")
             .attr("class", "label")
             .style("fill-opacity", function(d) { return d.parent === root ? 1 : 0; })
             .style("fill", "black")
             .style("font-size", "12px")
             .style("text-anchor", "middle")
             .text(function(d) { if(d.data.value>=1){return d.data.name; } });

  //allow to zoom out
  svg1.on("click", function() { d3.select(child)._groups[0][0].remove(); cloneZoom= false; zoom(root);  objectSelected = children; mainPage(children, firstCreation); } );

  //calculate the cordinates of the circles representing the clones
  nodeProperties([root.x, root.y, root.r * 2], root);

  //display de bar chart graph, the sequences, the selection area and the abundance table
  mainPage(children, firstCreation);
  firstCreation = false;
   
  //separate clones from clonotypes
  function parseClone(data, clonotypes){
    clones = {"value": data["value"], "color": data["color"], "stroke": data["stroke"], "style": data["style"],"children" : []}
    //browse the data and store all the clones the variable "clones" and in the variable "clonotypes"
    for(var i in data.children){
      clones["children"].push({"name": data.children[i]["name"], "length": data.children[i]["length"], "value": data.children[i]["value"], "color": data.children[i]["color"], "stroke": data.children[i]["stroke"], "style": data.children[i]["style"], "idV": data.children[i]["idV"], "idJ": data.children[i]["idJ"], "cdr3": data.children[i]["cdr3"], "productivity": data.children[i]["productivity"]});
      clonotypes.push({"name": data.children[i]["name"], "length": data.children[i]["length"], "value": data.children[i]["value"], "color": data.children[i]["color"], "stroke": data.children[i]["stroke"], "style": data.children[i]["style"], "idV": data.children[i]["idV"], "idJ": data.children[i]["idJ"], "cdr3": data.children[i]["cdr3"], "productivity": data.children[i]["productivity"]});
      //store the clonotypes of the clone in the variable "clonotypes" if there are any
      if(data.children[i].children){
        clonotypes[i].children = data.children[i].children;
      }
    }
    return clones;
  }

  //set the size of the nodes
  function nodeProperties(v,child) {
    var k = (diameter / (v[2])); view = v;
    //modify the cordinate of the cercle representing the clones depending on the view
    parentNodes.attr("transform", function(d) { return "translate(" + (d.x - v[0]) * k  + "," + (d.y - v[1]) * k + ")"; });
    parentNodes.selectAll("circle").attr("r", function(d) { return d.r * k; });
    //modify the cordinates of the circle representing the clonotypes if we are zooming in
    if(cloneZoom){
      child.attr("transform", function(d) { return "translate(" + (d.x-(v[2]/2))*k + "," + (d.y-(v[2]/2)) *k + ")"; });
      child.selectAll("circle").attr("r", function(d) { return d.r * k; });
      parentNodes.selectAll("text").style("display","none")
      child.selectAll("text").style("display","inline")
    }else{
    //remove the circle representing the clonotypes of the clones because we are zooming out
      svg1.selectAll(".childNodes").remove();
      parentNodes.selectAll("text").style("display","inline");
    }
  }

  //allow to zoom in or out of the clone in the zooming circle packing reprsentation
  function zoom(d){
    //change the focus variable into the object we are on
    var focus0 = focus; focus = d;
    var transition = d3.transition()
                  .duration(750)	//specify the duration of the transition in miliseconde
                  .tween('zoom', function(d) {			//run custom code during the transition
                                               var transitionFunction = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2]);	//apply betwen two views (starts and end)
                                               return function(t) { nodeProperties(transitionFunction(t),child); };
                  });
  }

  function displayClonotype(d,i){
    var focusIndex = i;	//index of the clone we are zooming on
    //store the radius of all the clones
    var parentRadius = packLayout(root).descendants().filter(function(d) { return d.depth == 1; }).map(function(d) { return d.r; });
    //creation of child pack layout
    var childPack = d3.pack().size([parentRadius[i-1]*2 , parentRadius[i-1]*2 ]).padding(6);
    //child pack to represente the clonotypes

    var childRoot =  d3.hierarchy(children[i-1])
	         .sum(function(d) { return d.value_rep; });
    childRoots = childPack(childRoot).descendants(); 
    //create the child circle pack, add a g container for each clonotype
    var childNodes = parentNodes.filter( function(d,i){ local.set(this, d); return i == focusIndex}) //keep g in the local variable and filter to retrieve the concerned node
                                .selectAll("g")
                                .attr("class","childNodes")
                                .data(childRoots)
                                .enter()
                                .append("g")
                                .attr("transform", function(d) { var offset = local.get(this).r; return "translate(" + (d.x-offset)  + "," + (d.y-offset)  + ")"; })

    //create circle on each g container of the clonotypes and add style to this circle
    childNodes.filter(function(d) { return d.depth > 0 })  //skip parent, it's already drawn
              .append("circle")
              .attr("r", function(d) { return d.r ; })
              .style("opacity", 0.7)
              .style("stroke-width", 2)
              .style("fill", function(d){ return d.data.color; })
              .style("stroke", function(d){ return d.data.stroke; })
              .style("stroke-dasharray", function(d){ return d.data.style; })

    //add name of the clone on the circle
    childNodes.append("text")
              .attr("class", "label")
              .filter(function(d,i) { return i >0; } )	//do not count the root
              .style("fill", "black")
              .style("font-size", "12px")
              .style("text-anchor", "middle")
              .text(function(d) { if(d.data.value>=1){ return d.data.name }});

    return childNodes
  }

})


// **************************************** Show the elements present on the main page **********************************************

  function mainPage(dataClone, state){
    //remove content of barChart when we are zooming out
    document.getElementById("nextButton").style.display = "none";
    //display the bar chart
    var chart = document.getElementById('barChart')
    chart.style.display = "flex";
    //deactivate tree container
    document.getElementById("clonotypeTree").style.display = "none";
    //deactivate radios button
    document.getElementById("treeForm").style.display = "none";
    //deactivate checkbox
    document.getElementById("checkboxProductivity").style.display = "none";
    //display the form which allows to enter a threshold value
    var form = document.getElementById('thresholdSelection');
    form.style.display = "block";
    //deactivate the clonotype table
    var clonotypeTable = document.getElementById('cloneTable');
    clonotypeTable.innerHTML = "";
    //table that contain the data of clones
    tableData(dataClone, ["Clone", "Abundance(%)", "Number of reads", "V region", "J region", "cdr3", "Productivity"], ["name","value","reads", "idV","idJ","cdr3", "productivity"]);
    //create the different element if the user load the page for the first time
    if(state){
      //create bar chart representation
      barChart(dataClone.slice(0,9));
    }
  }



// **************************************** Bar chart representing abundance of clones **********************************************

  function barChart(data){
    // set the dimensions and margins of the diagram
    var margin = {top: 20, right: 10, bottom: 50, left: 70},
        width = ((document.getElementById('barChart').offsetWidth)/1.5) - (margin.left + margin.right),	//get width of barChart element in px 
        height = (document.getElementById('barChart').offsetHeight/1.25) - (margin.top + margin.bottom);

    //set the ranges depending on the width and height
    const x = d3.scaleBand()
           .range([0, width])
           .padding(0.1);

    const y = d3.scaleLinear()
           .range([height, 0]);

    //create svg object
    var svg2 = d3.select("#barChart").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
        .append("g")
         .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    //set the axis range depending on the value
    yMax = (d3.max(data, function(d) { return parseFloat(d["value"]); }));
    x.domain(data.map(function(d) { return d["name"]; }));
    y.domain([0, yMax]);

    //add the x axis to the svg
    svg2.append("g")
        .attr("transform", "translate(0," + height + ")")
        .call(d3.axisBottom(x).tickSize(0))
        .selectAll("text")	
            .style("text-anchor", "end")
            .attr("dx", "-.8em")
            .attr("dy", ".15em")
            .attr("transform", "rotate(-65)");
    
    //add the y axis to the svg
    svg2.append("g").call(d3.axisLeft(y).ticks(6));

    //add the bar corresponding to the abundance of the clones. The width of the bar is determined by the function x and the height by the y function
    svg2.selectAll(".bar")
        .data(data)
        .enter().append("rect")
        .style("fill", function(d){ return d.color; })
        .attr("x", d => x(d["name"]))
        .attr("width", x.bandwidth())
        .attr("y", d => y(d["value"]))
        .attr("height", d => height - y(d["value"]));

    //text label for the y axis
    svg2.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", 0 - margin.left)
        .attr("x",0 - (height / 2))
        .attr("dy", "1em")
        .style("text-anchor", "middle")
        .style("font", "0.8em 'Trebuchet MS'")
        .text("Abundance (%)");   

     //the user doesn't enter a threshold value
     if(threshold==-1){threshold=yMax;}
     // Draw the line for the threshold
     svg2.append("line")
         .attr("class","thresholdLine")
           .attr("x1", 0)
           .attr("y1", y(threshold))
           .attr("x2", width)
           .attr("y2", y(threshold));
  }



// ******************************************** Data of the clones and clonotypes ****************************************************

  function tableData(data, heading, value){

    //select the div element which will contain the sequences
    var table = document.getElementById('cloneTable');
    //create a thead element and add it to the table
    var thead = document.createElement('thead');
    table.appendChild(thead);
    //create a tr element and add it to the table
    var tr = document.createElement('tr');
    thead.appendChild(tr);

    for(var i in heading){

      //create the title of the column 
      var th = document.createElement('th');
      th.appendChild(document.createTextNode(heading[i]));

      //add the title to the table
      tr.appendChild(th);
    
    }

    //create a tbody element and add it to the table
    var tbody = document.createElement('tbody');
    table.appendChild(tbody);

    //browse the clones and show the sequences for each of them
    for(var i in data){ 

      //create a tr element to add a line and add it to the table
      var tr = document.createElement('tr');
      tbody.appendChild(tr);

      for(var j in value){

        //create a td element to add a cell
        var td = document.createElement('td');
        //create a p element which will contain the data of the clone or clonotype
        var p = document.createElement('p');
        p.classList = "tableSeqCell";
        p.appendChild(document.createTextNode(data[i][value[j]]));
        //add it to the td element
        td.appendChild(p);

         //add all the element created to the table      
         tr.appendChild(td);
    
      }
    }
  }


// ************************************** Load the page showing the description of a clone *******************************************

  function clonePage(dataClonotypes, clone){
    //remove the elements of the main page
    //deactivate the bar chart elements
    var threshold = document.getElementById('thresholdSelection');
    threshold.style.display = "none";
    var chart = document.getElementById('barChart');
    chart.style.display = "none";
    //deactivate the clone table
    var cloneTable = document.getElementById('cloneTable');
    cloneTable.innerHTML = "";
    //table of clonotypes data
    tableData(dataClonotypes, ["Clonotype", "Abundance in repertoire (%)", "Abundance in clone (%)", "cdr3", "Productivity", "Sequence"], ["name", "value_rep", "value", "cdr3", "productivity", "seq"]);
    //activate button to access to the description of clones
    document.getElementById("nextButton").style.display = "block";
    //activate the radios button to change the form of the tree
    document.getElementById("treeForm").style.display = "block";
    //activate the checkbox to visualise the productivity
    document.getElementById("checkboxProductivity").style.display = "block";
    //launch the tool to obtained hierarchy of clonotypes
    //activate tree container
    document.getElementById("clonotypeTree").style.display = "block";
    d3.select("#clonotypeTree svg").remove()
    //represent these data in the form of a tree 
    document.getElementById("circleTree").checked = true;
    displayTree();
  }


// ******************************* Allows the user to download all the information of the repertoire ********************************

  function downloadClonesInformations(){
    var download = "", heading = [];
    if("idV" in objectSelected[0]){ fileName = "repertoire"; }else{ fileName = "clone"+objectSelected[0]["name"].split("-")[0]; }
    //recover the title 
    for(var title in objectSelected[0]){
      if(!(title in {"children":"","color":"","stroke":"","style":""})){ 
        heading.push(title); 
        download += title+";";
      }
    }
    download += "\n"
    //add all the clone or clonotype
    for(var i in objectSelected){
      for(var j in heading){
        download += objectSelected[i][heading[j]]+";";
      }
      download += "\n";
    }
    var textToBLOB = new Blob([download], {type : 'text/plain' });
    var fileSave = fileName+'_data.txt';
    var newLink = document.createElement("a");
        newLink.download = fileSave;
    
    if (window.webkitURL != null) {
            newLink.href = window.webkitURL.createObjectURL(textToBLOB);
        }
        else {
            newLink.href = window.URL.createObjectURL(textToBLOB);
            newLink.style.display = "none";
            document.body.appendChild(newLink);
        }

        newLink.click(); 
  }

// ********************************* Display of clonotype tree for a given clone ****************************************************

function displayTree(){
  d3.select("#clonotypeTree svg").remove();
  var colorProd = document.getElementById("productivity"); // checkbox element
  var treeBranches = [], maxAbundance=0; 
  
  cloneName = objectSelected[0]["name"].split("-")[0];
  localStorage.setItem( 'clone', cloneName );

  //CAUTOUS : call the tool for analyse the intraclonal heterogeneity

  var user = "<?php echo $userFile; ?>",
      file = user +"_"+cloneName+"_clonotype.json";
      path = "pipeline/usersFiles/"+user+"/tree/"+file;

  //loading the json file
  d3.json(path, function(error, dataTree) {
    if (error) throw error;

    var data = d3.hierarchy(dataTree); //data structure that represente a hieratchy

    //store the most abundant clonotypes and the value of the longest branch of the tree
    treeBranches = findMostAbundantClonotypes(data); 

    //branch length for the circular tree
    //changeDepth(data);

    //create the svg object and the layout depending on the form of the tree
    if(form==0){
      //set the dimensions and margins of the diagram
      var margin = {top: 20, right: 10, bottom: 20, left: 10},
      width = (document.getElementById('chart2').offsetWidth) - margin.left - margin.right,
      height = (document.getElementById('chart2').offsetHeight) - margin.top - margin.bottom;

      //add an svg object to the chart2 element
      var svg2 = d3.select("#clonotypeTree").append("svg")
              .attr("width", width + margin.left + margin.right)
              .attr("height", height + margin.top + margin.bottom)
            .append("g")
              .attr("transform", "translate(" + width/2 +','+ height/2 + ")");

      // declares a tree layout and assigns the size
      var tree = d3.tree()	//creating the tree layout 
              .size([2 * Math.PI, height/2])
              .separation(function(a, b) { return ((a.depth >= 2) && (b.depth >= 2)) ? 1 : 4; });
    }else{
      //set the dimensions and margins of the diagram
      var margin = {top: 60, right: 60, bottom: 60, left: 60},
      width = (document.getElementById('chart2').offsetWidth) - margin.left - margin.right,
      height = (document.getElementById('chart2').offsetHeight) - margin.top - margin.bottom;

      //add an svg object to the chart2 element
      var svg2 = d3.select("#clonotypeTree").append("svg")
              .attr("width", width + margin.left + margin.right)
              .attr("height", height + margin.top + margin.bottom)
            .append("g")
              .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      // declares a tree layout and assigns the size
      var tree = d3.tree()	//creating the tree layout 
              .size([width, height])
              .separation(function(a, b) { return ((a.depth >= 2) && (b.depth >= 2)) ? 1 : 5; });
    }


    //parameters use to collapse the tree       
    var duration = 750, i=0;
    data.x0 = height / 2;
    data.y0 = 0;

        var maxSizeNode = width/(data.leaves().length+1), 
            minSizeNode = (width/(data.leaves().length+1))*0.9,
            //maxSizeNode = Math.min(maxSizeWidth,maxSizeHeight)
            nodeSizeFactor = (maxSizeNode-minSizeNode)/treeBranches[3],  //abundance scale unit
            yUnit = (height-((treeBranches[2]*nodeSizeFactor)+minSizeNode))/treeBranches[1];  //value of a nucleotide in pixel


// Collapse the second level
//data.children.forEach(collapse);

updateTree(data);

// Collapse the node and all it's children
function collapse(d) {
  if(d.children) {
    d._children = d.children
    d._children.forEach(collapse)
    d.children = null
  }
}

function updateTree(source) {

  //assign properties to the data (coordinates, depth, ...)
  var root = tree(data);

  // Compute the new tree layout.
  var nodes = root.descendants(),
      links = root.descendants().slice(1);

  // ********* Creation of the nodes *********

  //add each node as a group
  var node = svg2.selectAll('g.nodeTree')
      .data(nodes, function(d) {return d.id || (d.id = ++i); });

  //add new nodes at the parent's previous position
  var nodeEnter = node.enter().append('g')
               .attr('class', 'nodeTree')
               .attr("transform", function(d) { if(form==0){ return "translate(" + radialPoint(source.x0, source.y0) + ")"; }else{ return "translate(" + source.x0 + "," + source.y0 + ")"; } })	//position the nodes
               .on('click', changeChildren)
               .on("mouseover", function(d) { var g = d3.select(this); //g object of the node
                                              var info = g.append('text').classed('info', true).attr('x', -25).attr('y', function(d) { return -(10+(d.data.value*0.1))}).text(function(d) { if(d.data.name!="ighv"){ return d.data.name; }}).attr('font-size', 12) ;})
               .on("mouseout", function() { d3.select(this).select('text.info').remove()}); //remove the text on mouse out

        // adds the circle to the node
        nodeEnter.append("path")
                 .attr('class', 'nodeTree')
                 .style("fill", function(d){if(colorProd.checked){ 
                                              if(d.data.productivity=="yes"){ return "#28b463";}
                                              else if(d.data.productivity=="no"){ return "#e74c3c";}
                                              else{ return "#999999";}
                                            }else{return d.data.color;}})
                 .style("stroke", function(d){ if(colorProd.checked){return "#000000";}else{return d.data.stroke;} })
                 .style("stroke-dasharray", function(d){ if(colorProd.checked){return "none";}else{return d.data.style;} })
                 .attr("d", d3.symbol().size(function(d) { return d.data.value? (nodeSizeFactor*parseFloat(d.data.value))+minSizeNode : 0} )
                                       .type(function(d) { if(d.data.name=="ighv"){return d3.symbolTriangle;
                                                           }else{return d3.symbolCircle;}
                                                         }));


        //add text to the node
        nodeEnter.append("text")
                 .attr('font-size', 12) //set the size of the text
                 .attr("dy", function(d) { return 20+(d.data.value*0.1);})	//set the emplacement of the text
                 .attr("dx", 15)
                 .attr("text-anchor", "middle")
                 .text(function(d) { if(d.data.name!="ighv" && d.parent.data.name=="ighv"){ return d.data.name; }})
                 .clone(true).lower();

        //update node
        var nodeUpdate = nodeEnter.merge(node);

        //transition to the proper position for the node
        nodeUpdate.transition().duration(duration)
                  .attr("transform", function(d) { if(form==0){ return "translate(" + radialPoint(d.x, d.y) + ")";}else{return "translate(" + d.x + "," + d.y + ")";} });

        nodeUpdate.select('path.nodeTree')
                  .attr("d", d3.symbol().size(function(d) { return d.data.value? (nodeSizeFactor*parseFloat(d.data.value))+minSizeNode : 0})
                                        .type(function(d) { if(d.data.name=="ighv"){return d3.symbolTriangle;
                                                            }else{return d3.symbolCircle;}}))
                  .attr('cursor', 'pointer');

        //remove any exiting nodes
        var nodeExit = node.exit().transition()
                    .duration(duration)
                    .attr("transform", function(d) { if(form==0){ return "translate(" + radialPoint(source.x, source.y) + ")";}else{return "translate(" + source.x + "," + source.y + ")";} })
                    .remove();

        //reduce the node circles size to 0
        nodeExit.select('path.nodeTree').attr("d", d3.symbol().size(0));

        // ********* Creation of links *********

        //add the links between the nodes
        var link = svg2.selectAll("path.linkTree").data(links, function(d) { return d.id; });
  
        var linkEnter = link.enter().insert('path',"g")	//SVG path allow to draw shape
                     .attr("class", "linkTree")
                     .style("stroke", "#555")
                     .attr("d", function(d){ var s = {x : source.x0, y : source.y0}; return branchShape(s, s);});

        //update link
        var linkUpdate = linkEnter.merge(link);

        //transition back to the parent element position
        linkUpdate.transition()
                  .duration(duration)
                  .attr("d", function(d){ return branchShape(d, d.parent); });

        //remove any exiting links
        var linkExit = link.exit().transition()
                    .duration(duration)
                    .attr("d", function(d){ var s = {x : source.x, y : source.y}; return branchShape(s, s);})
                    .remove();

  // Store the old positions for transition.
  nodes.forEach(function(d){
    d.x0 = d.x;
    d.y0 = d.y;
  });


}

  function changeChildren(d) {
    if (d.children) {
        d._children = d.children;
        d.children = null;
      } else {
        d.children = d._children;
        d._children = null;
      }
    updateTree(d);
  }
   
  });


  function radialPoint(x, y) {
	return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
  }

  //give the start and end point to a branch    
  function branchShape(s,t) {
    if(form==0){
      return "M" + radialPoint(s.x, s.y)[0] + "," + radialPoint(s.x, s.y)[1] + " " + radialPoint(t.x, t.y)[0] + "," + radialPoint(t.x, t.y)[1]; //M means move to
    }else{
      return "M" + s.x + "," + s.y + "V" + t.y + "H" + t.x;}
    }
  }

  function changeDepth(d){
    for(var i in d.children){ 
      d.children[i].depth = d.depth+(1*d.children[i].data["length"]);
      if (d.children[i].children){changeDepth(d.children[i]);}
    }
  }

//browse the tree of clonotypes to find the 5 first clonotypes with the most abundance
function findMostAbundantClonotypes(data){
  var longestTreeBranch = [0,0,0,0], lengthBranch = [], nodeSize = [], maxAbundance = [];
  //for each children of the given node 
  for(var i in data.children){
    //look among the children of this node if there are clonotypes with more abundance
    if(data.children[i].children){ 
      longestTreeBranch = findMostAbundantClonotypes(data.children[i]);
      //add to a table all the length of the branch
      lengthBranch.push(longestTreeBranch[1]+parseFloat(data.children[i].data.length));
      nodeSize.push(longestTreeBranch[2]+(parseFloat(data.children[i].data.value)/100));
    }else{    
      //add to a table all the length of the branch
      lengthBranch.push(parseFloat(data.children[i].data.length));
      nodeSize.push(parseFloat(data.children[i].data.value)/100);
    }
    maxAbundance.push(parseFloat(data.children[i].data.value));
  }

  longestTreeBranch[0] += 1;
  for(var j in lengthBranch){
    if(lengthBranch[j]+nodeSize[j]>longestTreeBranch[1]+longestTreeBranch[2]){
      longestTreeBranch[1]=lengthBranch[j];
      longestTreeBranch[2]=nodeSize[j];
    }
  }

  if(Math.max.apply(null,maxAbundance)>longestTreeBranch[3]){ longestTreeBranch[3]=Math.max.apply(null,maxAbundance); }

  return longestTreeBranch;
}


</script>
