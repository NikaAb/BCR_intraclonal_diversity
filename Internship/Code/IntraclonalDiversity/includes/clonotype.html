  <?php $userFile = $_COOKIE['Userfile']; ?>
  <div style="width: 100%; height: 800px;">
    <br>
    <div id="chart1" style="width: 50%; height: 50%; float: left;" >
      <div id="checkboxProductivity">
        <input type="checkbox" id="productivity" name="productivity" onClick="displayTree();">
        <label for="productivity">Productivity (green productive)</label>
      </div>
    </div>
    <div id="chart2" style="margin-left: 50%; height: 50%;"></div>
    <!-- Button to change the tree form --> 
    <div id="treeForm" style="margin-left: 2%; ">
      <div><input type="radio" name="treeForm" id="circleTree" onClick="changeTree(this.value);" value=0 checked>
      <label for="circleTree">Circular tree</label></div>
      <div><input type="radio" name="treeForm" id="elbowTree" onClick="changeTree(this.value);" value=1>
      <label for="elbowTree">Elbow tree</label></div>
    </div><br><br>
    <div id="chart3" style="width: 100%; height: 50%;">
    </div>
  </div>

  <script>
    var clone = localStorage['clone'];
    var selectedNode = [], firstTime = true, form = 0;
    displayTree(0);

function changeTree(typeTree){
  form = typeTree;
  displayTree();
}

//****************** Tree

function displayTree(){
  d3.select("#chart1 svg").remove();
  var colorProd = document.getElementById("productivity"); // checkbox element 

  var user = "<?php echo $userFile; ?>",
      file = user +"_"+clone+"_clonotype.json";
      path = "pipeline/usersFiles/"+user+"/"+file;

  //loading the json file
  d3.json(path, function(error, dataTree) {
  if (error) throw error;

    var data = d3.hierarchy(dataTree); //data structure that represente a hieratchy
    changeDepth(data);

    if(firstTime){
      //store the most abundant clonotypes
      findMostAbundantClonotypes(data, selectedNode);
       
      distancesRepresentation(selectedNode);
      
      //create the table of the sequences
      //displaySequence(data.children);
    }

    //retrieve the name of all the clonotypes selected
    var clonotypesName = selectedNode.map(function(d){ return d.data.name });

    //create the svg object and the layout depending on the form of the tree
    if(form==0){
      //set the dimensions and margins of the diagram
      var margin = {top: 5, right: 5, bottom: 5, left: 5},
      width = (document.getElementById('chart1').offsetWidth) - margin.left - margin.right,
      height = (document.getElementById('chart1').offsetHeight) - margin.top - margin.bottom;

      //add an svg object to the chart2 element
      var svg1 = d3.select("#chart1").append("svg")
              .attr("width", width + margin.left + margin.right)
              .attr("height", height + margin.top + margin.bottom)
            .append("g")
              .attr("transform", "translate(" + width/2 +','+ height/2 + ")");

      // declares a tree layout and assigns the size
      var tree = d3.tree()	//creating the tree layout 
              .size([2 * Math.PI, height/2])
              .separation(function(a, b) { return ((a.depth >= 2) && (b.depth >= 2)) ? 1 : 4; });
    }else{
      //set the dimensions and margins of the diagram
      var margin = {top: 50, right: 50, bottom: 50, left: 60},
      width = (document.getElementById('chart1').offsetWidth) - margin.left - margin.right,
      height = (document.getElementById('chart1').offsetHeight) - margin.top - margin.bottom;

      //add an svg object to the chart2 element
      var svg1 = d3.select("#chart1").append("svg")
              .attr("width", width + margin.left + margin.right)
              .attr("height", height + margin.top + margin.bottom)
            .append("g")
              .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      // declares a tree layout and assigns the size
      var tree = d3.tree()	//creating the tree layout 
              .size([width, height])
              .separation(function(a, b) { return ((a.depth >= 2) && (b.depth >= 2)) ? 1 : 2.5; });
    }
              
      var duration = 750;
      data.x0 = height / 2;
      data.y0 = 0;

      //data.children.forEach(collapse);

      updateTree(data);

      function updateTree(source){

        //assign properties to the data (coordinates, depth, ...)
        var root = tree(data);


        // ********* Creation of the nodes *********

        //add each node as a group
        var node = svg1.selectAll("g")
                .data(root.descendants());

        var nodeEnter = node.enter().append("g")
                     .attr("transform", function(d) { return "translate(" + radialPoint(source.x0, source.y0) + ")";})	//position the nodes
                     .on('click', selectClonotype)
                     .on('dblclick', changeChildren)
                     .on("mouseover", function(d) { var g = d3.select(this); //g object of the node
                                                    var info = g.append('text').classed('info', true).attr('x', -20).attr('y', function(d) { return -(5+(2*d.data.value))}).text(function(d) { if(d.data.name!="naive"){ return d.data.name; }}).attr('font-size', 12) ;})
                     .on("mouseout", function() { d3.select(this).select('text.info').remove()}); //remove the text on mouse out

        // adds the circle to the node
        nodeEnter.append("circle")
                 .style("fill", function(d){if(colorProd.checked){ 
                                              if(d.data.productivity=="yes"){ return "#28b463";}
                                              else if(d.data.productivity=="no"){ return "#e74c3c";}
                                              else{ return "#999999";}
                                            }else{return d.data.color;}})
                 .style("stroke", function(d){ if(colorProd.checked){return "#000000";}else{return d.data.stroke;} })
                 .style("stroke-dasharray", function(d){ if(colorProd.checked){return "none";}else{return d.data.style;} })
                 .style("stroke-width", 1)
                 .attr("r", function(d) { return d.data.value? 2*d.data.value : 0}); //set the diameter of the node

        //add text to the node
        nodeEnter.append("text")
                 .attr('font-size', 11) //set the size of the text
                 .attr("dy", function(d) { return 15+(2*d.data.value)})	//set the emplacement of the text
                 .attr("dx", 15)
                 .attr("text-anchor", "middle")
                 .text(function(d) { if(d.data.name!="naive" && d.parent.data.name=="naive"){return d.data.name;}})
                 .clone(true).lower()
                 .attr("stroke", "white");

       //display the clone selected
       nodeEnter.filter(function (d, i) { if(clonotypesName.indexOf(d.data.name)!=-1){ return d.data.name; }})
                .style("font-weight", "bold")
                .classed("selected",true)
                .selectAll("circle").style("stroke-width", 3);

        var nodeUpdate = nodeEnter.merge(node);

        //transition to the proper position for the node
        nodeUpdate.transition()
                  .duration(duration)
                  .attr("transform", function(d) { if(form==0){ return "translate(" + radialPoint(d.x, d.y) + ")";}else{return "translate(" + d.x + "," + d.y + ")";} });

        nodeUpdate.select('circle')
                  .attr('r', function(d) { return d.data.value? 2*d.data.value : 2})
                  
                  .attr('cursor', 'pointer');

        //remove any exiting nodes
        var nodeExit = node.exit().transition()
                    .duration(duration)
                    .attr("transform", function(d) { if(form==0){ return "translate(" + radialPoint(source.x, source.y) + ")";}else{return "translate(" + source.x + "," + source.y + ")";} })
                    .remove();

        // ********* Creation of links *********

        //add the links between the nodes
        var link = svg1.selectAll("path")
                .data(root.descendants().slice(1));
              
        var linkEnter = link.enter().insert('path',"g")	//SVG path allow to draw shape
              .attr("fill", "none")
              .attr("stroke", "#555")
              .attr("stroke-opacity", 0.5)
              .attr("stroke-width", 2)
                     .attr("d", function(d){ var s = {x : source.x0, y : source.y0}; return branchShape(source, source, form);});

        //update link
        var linkUpdate = linkEnter.merge(link);

        //transition back to the parent element position
        linkUpdate.transition()
                  .duration(duration)
                  .attr("d", function(d){ return branchShape(d, d.parent, form); });

        //remove any exiting links
        var linkExit = link.exit().transition()
                    .duration(duration)
                    .attr("d", function(d){ var s = {x : source.x, y : source.y}; return branchShape(s, s, form);})
                    .remove();

        root.descendants().forEach(function(d){ d.x0 = d.x; d.y0 = d.y;});

      }

      function changeChildren(d){
        if(d.children){
          d._children = d.children;
          d.children = null;
        }else{
          d.children = d._children;
          d._children = null;
        }
        updateTree(d);
      }

      firstTime = false;

      //action performes when nodes are selected or deselected
      function selectClonotype(d){
        if (!d3.select(this).classed("selected")) {
          if(selectedNode.length>8){
            alert("Can't show the distance of more than 8 clonotypes")
          }else{
            selectedNode.push(d); //add the clonotype selected in the array containing all the element selected
            d3.select(this)	//change the style of the selected clonotype
              .style("font-weight", "bold")
              .classed("selected",true)
            d3.select(this).selectAll("circle")
                .style("stroke-width", 3);
          }
        }else{
          index = clonotypesName.indexOf(d.data.name);
          d3.select(this)	//change the style of the deselected clonotype
            .style("font-weight", "normal")
            .classed("selected",false);
          d3.select(this).selectAll("circle")
              .style("stroke-width", 1);
          selectedNode.splice(index,1) 	//delete the clonotype from the array with all the selected element 
        }
        d3.select("#chart2 svg").remove();
        distancesRepresentation(selectedNode);
      }

});
}

      function radialPoint(x, y) {
	return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
      }

      function changeDepth(d){
        for(var i in d.children){ d.children[i].depth = d.depth+(1*d.children[i].data["length"]);
        if (d.children[i].children){changeDepth(d.children[i]);}}
      }

      //**************************************** distance ****************************************************

  //create the representation of the distances
  function distancesRepresentation(distanceOfClonotypes){

      var distanceTable = [] //store the clonotypes for which the distance will be represented on the chart
      //retrieve the name of all the clonotypes selected
      var clonotypesName = distanceOfClonotypes.map(function(d){ return d.data.name });
      createDistanceTable(distanceTable, distanceOfClonotypes); //table of the distance of the 5 most abundant clonotypes that'll be use in the graph representing the distance

      width = (document.getElementById('chart2').offsetWidth );	//get width of chart2 element in px 
      height = (document.getElementById('chart2').offsetHeight );
      chartRadius = height / 2 - 25;

var svg = d3.select('#chart2').append('svg')
  .attr('width', width)
  .attr('height', height)
  .append('g')
    .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');

var tooltip = d3.select('#chart2').append('div')
  .attr('class', 'tooltip');

var pi = Math.PI,
  arcPosition = 50,	//position of the arc relative to the center
  arcPadding = 10;	//space between the different arcs

  var maxDistance = d3.max(distanceTable, function(d){ return d.length });
  //create a quantitative linear scale. This function map data values into visual variables
  var scale = d3.scaleLinear()
    .domain([0, maxDistance * 1.33])	//minimum and maximum values of the input data (the min and max distance between clonotype)
    .range([0, 2 * pi]); //range of values to which the distance values match

  //array of values sampled from the scale’s domain
  var ticks = scale.ticks(maxDistance);

  //number of clonotypes
  var numClonotypes = clonotypesName.length;
  //calculation of the width of the arcs according to the number of clonotypes
  var arcWidth = (chartRadius - arcPosition - numClonotypes * arcPadding) / numClonotypes;

//create a new arc generator
  var arc = d3.arc()
         .innerRadius(function(d, i){ return getInnerRadius(parseInt(distanceTable[i].index)); }) //set the inner radius to a specific value determine by a function
         .outerRadius(function(d, i){ return getOuterRadius(parseInt(distanceTable[i].index)); })
         .startAngle(function(d, i){ return scale(parseInt(distanceTable[i].start)); })	//determine the start angle for the arcs
         .endAngle(function(d){ return scale(d); });	//end angle of the cercle determine by the scale function

  //create radial axis to add text to identify the different axes
  var radialAxis = svg.append('g')
    .selectAll('g')
      .data(distanceTable)
      .enter().append('g');

  radialAxis.append('text')
    .style('font', '12px sans-serif')
    .attr('x', -45)
    .attr('y', function(d, i){ return (-getOuterRadius(i) + arcPadding); })
    .text(function(d,i){ return clonotypesName[i]; });

  //create axial axis to identify the distances
  var axialAxis = svg.append('g')
    .selectAll('g')
      .data(ticks)
      .enter().append('g')
        .attr('transform', function(d) { return 'rotate(' + ((scale(d) * 180 / pi) - 90) + ')'; });

  //add line to the axial axis
  axialAxis.append('line')
    .style("stroke", "#cccccc")
    .style("stroke-width", "1px")
    .attr('x2', chartRadius);

  axialAxis.append('text')
    .attr('x', chartRadius + 10)
    .style('font', '12px sans-serif')
    .style('text-anchor', function (d) { return (scale(d) >= pi && scale(d) < 2 * pi ? 'end' : null); })
    .attr('transform', function (d) { return 'rotate(' + (90 - (scale(d) * 180 / pi)) + ',' + (chartRadius + 10) + ',0)'; })
    .text(function(d){ return d; });

  //data arcs
  var arcs = svg.append('g')
    .selectAll('path')
      .data(distanceTable)
      .enter().append('path')
      .style('fill', function(d, i) { return d.color; } )
      .style("stroke", function(d){ return d.stroke; })
        .style("stroke-dasharray", function(d){ return d.style; })
        .style("stroke-width", 0.75)

  arcs.transition()
    .delay(function(d, i) { return i * 200; } )
    .duration(750)
    .attrTween('d', arcTween);

  function arcTween(d, i) {
    var interpolate = d3.interpolate(0, d.length);
    return t => arc(interpolate(t), i);
  }

  //calculate the value of inner radius in function of the index of the clonotype
  function getInnerRadius(index) {
    return arcPosition + (numClonotypes - (index + 1)) * (arcWidth + arcPadding); //the position of the inner radius corresponds to the addition of distance from the center and the thickness of the other arcs according to the clonotype index
  }

  //calculate the value of outer radius in function of the index of the clonotype
  function getOuterRadius(index) {
    return getInnerRadius(index) + arcWidth; //the position of the outer radius correpond to the addition of the position of the inner radius and the tickness of the arc
  }
}

//browse the tree of clonotypes to find the 5 first clonotypes with the most abundance
function findMostAbundantClonotypes(node, table){
  //for each children of the given node 
  for(var i in node.children){
    //there is already 5 clonotypes stores in the tab
    if(table.length == 5){
      //Compare the abundance of the clonotypes to those in of the clonotypes in the tab
      comparisonOfAbundance(table, node.children[i]);
    }else{
      //add the clonotypes to the table
      table.push(node.children[i]);
      //sort the elment of the table depending on the abundance
      table.sort(function sortByAbondance(a, b){
        if (a.data.value < b.data.value){
          return -1;
        }else if (a.data.value > b.data.value){
          return 1;
        }
        return 0;
      });
      table.reverse();
    }
    //look among the children of this node if there are clonotypes with more abundance
    if(node.children[i].children){ findMostAbundantClonotypes(node.children[i], table); }
  }
}

//modify the table that store the most abundant clonotypes if clonotypewith a abundance superior is found
function comparisonOfAbundance(table, clonotype){
  var nbElement = table.length; 
  var superior = true;
  var indice = -1;
  //browse all the element of the table to find if the clonotype has an abindance superior to the other
  while( superior && (nbElement != 0)){
    if(parseFloat(clonotype.data.value)>table[nbElement-1].data.value){
      indice = nbElement-1; //store the position of the element 
    }else{
      superior=false;
    }
    nbElement--;
  }
  //modify the table if the clonotype have a abundance superior to the clonotype of the table
  if(indice!=-1){
    table.splice(indice, 0, clonotype); //add the clonotype to the table
    table.pop(); //delete the last element of the table
  }
}

//create an array which contain the five clonotpes with the most abundance to allow to draw the chart
function createDistanceTable(table, clonotypes){
  //browse the table containing the clonotype to represent
  for(var i in clonotypes){
    parentsLength = storeClonotypesAncestor(table, clonotypes[i], i, clonotypes[i].data.name);
  }
}

//browse all the parent of clonotype to add them to the array it is necessary to represent the distance
function storeClonotypesAncestor(table, clonotype, index, name){
  //browse in the parent of the clonotype
  if(clonotype.parent){
    parentsLength = storeClonotypesAncestor(table, clonotype.parent, index, name);
    //allow to know which name should be write on the graph
    if(name==clonotype.data["name"]){ appear=true; }else{ appear=false; }
    //cumulate the length of the parent to allow to draw the distances on the graph
    length = parseFloat(clonotype.data["length"])+parentsLength
    table.push({"name":clonotype.data["name"], "value":clonotype.data["value"], "length":length, "color":clonotype.data["color"], "index":index, "start":parentsLength, "stroke":clonotype.data["stroke"], "style":clonotype.data["style"]}); //add the clonotype to the table of clonotype
    return length;
  }else{
    return 0;
  }  
}
 

    function collapse(d){
      if(d.children){
        if(d.depth>=2){
          d._children = d.children;
          d._children.forEach(collapse);
          d.children = null;
        }else{
          d.children.forEach(collapse);
        }
      }
    }

    //give the start and end point to a branch    
    function branchShape(s,t,form) {
    if(form==0){
      return "M" + radialPoint(s.x, s.y)[0] + "," + radialPoint(s.x, s.y)[1] + " " + radialPoint(t.x, t.y)[0] + "," + radialPoint(t.x, t.y)[1]; //M means move to
    }else{
      return "M" + s.x + "," + s.y + "V" + t.y + "H" + t.x;
    }
  }

  </script>

