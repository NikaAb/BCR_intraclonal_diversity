 <h3 id="titleAnalysis"></h3>
  <div style="width: 100%; height: 800px;">
    <br>
    <div id="chart1" style="width: 60%; height: 70%; float: left;" ></div>
    <div id="chart2" style="margin-left: 60%; height: 70%;"></div>
    <!-- Button to change the tree form --> 
    <div id="treeForm" style="height: 5%; margin-left: 2%; ">
      <input type="checkbox" id="showAbundance" name="showAbundance" onClick="changeTree();">
      <label for="showAbundance">Display abundance</label>
    </div><br><br>
    <div id="chart3" style="width: 90%; height: 25%; overflow:auto; margin:auto;">
      <table id="tableSequence" style="width: 100%; height: 100%; ">
      </table>
    </div>
  </div>

  <script>

//title of the page :
titleAnalysis.innerText = "<?php echo $title; ?>";

    var clone = localStorage['clone'];
    //localStorage.removeItem( 'clonotypeData' ); // Clear the localStorage
    var selectedNode = [], firstTime = true, dataClonotypes, clonotypesDistances=[], treeBranches=[];

    var user = "<?php echo $userFile; ?>",
        file = user +"_"+clone+"_clonotype.json";
        path = "pipeline/usersFiles/"+user+"/tree/"+file;

    //loading the json file
    d3.json(path, function(error, dataTree) {
    if (error) throw error;

      //display only the 30 first clonotypes
      var file = [dataTree], clonotypesNames=[];
      firstClonotypes(file, 0, clonotypesNames);

      displayTree(dataTree);
      displaySequence(clonotypesNames);
    });

function changeTree(){
  displayTree(dataClonotypes);
}

//****************** Tree

function displayTree(dataTree){
  d3.select("#chart1 svg").remove();

    dataClonotypes = dataTree;

    var abCheckbox = document.getElementById("showAbundance"); // checkbox element
    var data = d3.hierarchy(dataTree); //data structure that represente a hieratchy
    //if(form==0){changeDepth(data);}

    if(firstTime){
      //store the most abundant clonotypes and the value of the longest branch of the tree
      treeBranches = findMostAbundantClonotypes(data, selectedNode);

      distancesRepresentation(selectedNode);
      
    }

    //retrieve the name of all the clonotypes selected
    var clonotypesName = selectedNode.map(function(d){ return d.data.name });

    var clonotypeTooltip = d3.select("#chart1").append("div")
                        .attr("class","tooltip");

    //create the svg object and the layout depending on the form of the tree
    //set the dimensions and margins of the diagram
    var margin = {top: 50, right: 50, bottom: 50, left: 60},
    width = (document.getElementById('chart1').offsetWidth) - margin.left - margin.right,
    height = (document.getElementById('chart1').offsetHeight) - margin.top - margin.bottom;

    //add an svg object to the chart1 element
    var svg1 = d3.select("#chart1").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
          .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // declares a tree layout and assigns the size
    var tree = d3.tree()	//creating the tree layout 
            .size([width, height])
            //.separation(function(a, b) { return ((a.depth >= 2) && (b.depth >= 2)) ? 1 : 5; });
    //}

      var duration = 0, i=0;
      data.x0 = height / 2;
      data.y0 = 0;
    
      if(abCheckbox.checked){
        var maxSizeNode = Math.pow((width/(data.leaves().length+1)),2), 
            minSizeNode = Math.pow((width/(data.leaves().length+1))*0.3,2),
            //maxSizeNode = Math.min(maxSizeWidth,maxSizeHeight)
            nodeSizeFactor = (maxSizeNode-minSizeNode)/parseFloat(selectedNode[0].data.value),  //abundance scale unit
            yUnit = (height-Math.sqrt((treeBranches[2]*nodeSizeFactor)+(minSizeNode*(treeBranches[0]+1))))/treeBranches[1];  //value of a nucleotide in pixel
      }else{
        var minSizeNode = Math.pow((width/(data.leaves().length+1))*0.5,2), 
            nodeSizeFactor = 0,  //abundance scale unit
            yUnit = (height-Math.sqrt(treeBranches[0]*minSizeNode))/treeBranches[1];  //value of a nucleotide in pixel
      }

      updateTree(data);

      function updateTree(source){

        //assign properties to the data (coordinates, depth, ...)
        var root = tree(data);

        determineNodeCoord(root, (width/(data.leaves().length)), nodeSizeFactor, yUnit, minSizeNode);

        // Compute the new tree layout.
        var nodes = root.descendants(),
            links = root.descendants().slice(1);

        // ********* Creation of the nodes *********

        //add each node as a group
        var node = svg1.selectAll('g.nodeTree').data(nodes, function(d) {return d.id || (d.id = ++i); });

        var nodeEnter = node.enter().append("g")
                     .attr('class', 'nodeTree')
                     .attr("transform", function(d) { return "translate(" + source.x0 + "," + source.y0 + ")"; })	//position the nodes
                     .on('click', selectClonotype)
                     .on("mousemove",function(d){ return showClonotype(d); })
                     .on("mouseout",hideClonotype);


        // adds the circle to the node
        nodeEnter.append("path")
                 .attr('class', 'nodeTree')
                 .style("fill", function(d){ return d.data.color; })
                 .style("stroke", function(d){ return d.data.stroke; })
                 .style("stroke-dasharray", function(d){ return d.data.style; })
                 .attr("d", d3.symbol().size(function(d) { return d.data.value? (nodeSizeFactor*parseFloat(d.data.value))+minSizeNode : 0 } )
                                       .type(function(d) { if(d.data.name=="ighv"){return d3.symbolTriangle;
                                                           }else if(d._children==true){return d3.symbolSquare;}else{return d3.symbolCircle;}
                                                         }));
        //add text to the node
        nodeEnter.append("text")
                 .attr('font-size', 12) //set the size of the text
                 .attr("dy", function(d) { return 15+(Math.sqrt((nodeSizeFactor*parseFloat(d.data.value))+minSizeNode)/2)})	//set the emplacement of the text
                 .attr("dx", 15)
                 .attr("text-anchor", "middle")
                 .text(function(d) { if(clonotypesName.indexOf(d.data.name)!=-1){return d.data.name;}})
                 .clone(true).lower()
                 .attr("stroke", "white");

       //display the clone selected
       nodeEnter.filter(function (d, i) { if((clonotypesName.indexOf(d.data.name)!=-1) || (clonotypesDistances.indexOf(d.data.name)!=-1) ){ return d.data.name; }})
                .style("font-weight", "bold")
                .classed("selected",true)
                .selectAll("path.nodeTree").style("stroke-width", 3);

        var nodeUpdate = nodeEnter.merge(node);

        //transition to the proper position for the node
        nodeUpdate.transition()
                  .duration(duration)
                  .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; });

        nodeUpdate.select('path.nodeTree')
                  .attr("d", d3.symbol().size(function(d) { return d.data.value? (nodeSizeFactor*parseFloat(d.data.value))+minSizeNode : 0 })
                                        .type(function(d) { if(d.data.name=="ighv"){return d3.symbolTriangle;
                                                            }else if(d.data._children){return d3.symbolSquare;}else{return d3.symbolCircle;}}))
                  .attr('cursor', 'pointer');

        //remove any exiting nodes
        var nodeExit = node.exit().transition()
                    .duration(duration)
                    .attr("transform", function(d) { return "translate(" + source.x + "," + source.y + ")"; })
                    .remove();

        //reduce the node circles size to 0
        nodeExit.select('path.nodeTree').attr("d", d3.symbol().size(0));


        // ********* Creation of links *********

        //add the links between the nodes
        var link = svg1.selectAll("path.linkTree").data(links, function(d) { return d.id; });
              
        var linkEnter = link.enter().insert('path',"g")	//SVG path allow to draw shape
                     .attr("class", "linkTree")
                     .style("stroke-width", function(d){if(clonotypesDistances.indexOf(d.data.name)!=-1){ return 4;}else{return 2;}})
                     .style("stroke", function(d){if(clonotypesDistances.indexOf(d.data.name)!=-1){ return "#000";}else{return "#555";}})
                     .attr("d", function(d){ var s = {x : source.x0, y : source.y0}; return branchShape(source, source);});

        //update link
        var linkUpdate = linkEnter.merge(link);

        //transition back to the parent element position
        linkUpdate.transition()
                  .duration(duration)
                  .attr("d", function(d){ return branchShape(d, d.parent); });

        //remove any exiting links
        var linkExit = link.exit().transition()
                    .duration(duration)
                    .attr("d", function(d){ var s = {x : source.x, y : source.y}; return branchShape(s, s);})
                    .remove();

          nodes.forEach(function(d){d.x0 = d.x; d.y0 = d.y;});

      }

      /*function changeChildren(d){
        if(d.children){
          d._children = d.children;
          d.children = null;
        }else{
          d.children = d._children;
          d._children = null;
        }
        updateTree(d);
      }*/

      firstTime = false;

      //action performes when nodes are selected or deselected
      function selectClonotype(d){
        if (!d3.select(this).classed("selected")) {
          if(selectedNode.length==8){
            alert("Can't show the distance of more than 8 clonotypes")
          }else{
            selectedNode.push(d); //add the clonotype selected in the array containing all the element selected
            d3.select(this)	//change the style of the selected clonotype
              .style("font-weight", "bold")
              .classed("selected",true)
            d3.select(this).selectAll("path.nodeTree")
                .style("stroke-width", 3);
          }
        }else{
          clonotypesName = selectedNode.map(function(d){ return d.data.name });
          index = clonotypesName.indexOf(d.data.name);
          d3.select(this)	//change the style of the deselected clonotype
            .style("font-weight", "normal")
            .classed("selected",false);
          d3.select(this).selectAll("path.nodeTree")
              .style("stroke-width", 1);
          selectedNode.splice(index,1); 	//delete the clonotype from the array with all the selected element
        }
        d3.select("#chart2 svg").remove();
        distancesRepresentation(selectedNode);
      }

      function showClonotype(d) {
        clonotypeTooltip.style("left", ((d3.event.pageX + 10)+"px"))
                        .style("top", ((d3.event.pageY + 15)+"px"))
                        .style('display', 'inline-block')
                        .html("Name : "+d.data.name + "<br> Abundance : "+ Math.round(d.data.value*100*100) / 100 + "%<br>Productivity : "+ d.data.productivity);
      }

      function hideClonotype() {
        clonotypeTooltip.style('display', 'none');
      }
//});
}

      function radialPoint(x, y) {
	return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
      }

      function changeDepth(d){
        for(var i in d.children){ 
          d.children[i].depth = d.depth+(1*d.children[i].data["length"]);
          if (d.children[i].children){changeDepth(d.children[i]);}
        }
      }

      //place the coordonate of the node depending on the size of the node and the lenght of the branch
      function determineNodeCoord(data, spaceBetweenNodes, nodeSizeFactor, yUnit, minSizeNode){
        var nbrLeaves=0;
        data.y = 0;
        nbrLeaves = determineXYCoord(data, nbrLeaves, spaceBetweenNodes, nodeSizeFactor, yUnit, minSizeNode);
      }

      //add the x and y coordinate to the node of the tree
      function determineXYCoord(data, nbrLeaves, spaceBetweenNodes, nodeSizeFactor, yUnit, minSizeNode){
        var xCoordSomme = 0, 
            cptChildren = 0; 
        for(var i in data.children){
          cptChildren += 1;
          data.children[i].y = data.y + yUnit*data.children[i].data.length + (Math.sqrt((parseFloat(data.children[i].data.value)*nodeSizeFactor)+minSizeNode)/2);
          if(data.children[i].children){ 
            nbrLeaves = determineXYCoord(data.children[i],nbrLeaves,spaceBetweenNodes,nodeSizeFactor, yUnit, minSizeNode); 
            xCoordSomme += data.children[i].x;  
          }else{
              nbrLeaves+=1;
            if(nbrLeaves>1){ 
              data.children[i].x = nbrLeaves*spaceBetweenNodes; 
              xCoordSomme +=nbrLeaves*spaceBetweenNodes;
            }else{
              data.children[i].x = spaceBetweenNodes/2; 
              xCoordSomme += spaceBetweenNodes/2;
            }
          }
        }
        data.x = xCoordSomme/cptChildren;
        return nbrLeaves;
      }

      //************************************************************************ distance *********************************************************************************************************

  //create the representation of the distances
  function distancesRepresentation(distanceOfClonotypes){
      var distanceTable = [] //store the clonotypes for which the distance will be represented on the chart
      //retrieve the name of all the clonotypes selected
      var clonotypesName = distanceOfClonotypes.map(function(d){ return d.data.name });
      createDistanceTable(distanceTable, distanceOfClonotypes); //table of the distance of the 5 most abundant clonotypes that'll be use in the graph representing the distance

      //margin = {top: 50, right: 10, bottom: 50, left: 100};
      width = (document.getElementById('chart2').offsetWidth );	//get width of chart2 element in px 
      height = (document.getElementById('chart2').offsetHeight );
      chartRadius = (Math.min(width, height) / 2) - 50;

var svg = d3.select('#chart2').append('svg')
  .attr('width', width)
  .attr('height', height)
  .append('g')
    .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');

var tooltip = d3.select('#chart2').append('div')
           .attr('class', 'tooltip');

var pi = Math.PI,
  arcPosition = 50,	//position of the arc relative to the center
  arcPadding = 10;	//space between the different arcs

  var maxDistance = d3.max(distanceTable, function(d){ return d.length });
  //create a quantitative linear scale. This function map data values into visual variables
  var scale = d3.scaleLinear()
    .domain([0, maxDistance * 1.33])	//minimum and maximum values of the input data (the min and max distance between clonotype)
    .range([0, 2 * pi]); //range of values to which the distance values match

  //array of values sampled from the scale’s domain
  var ticks = axisStepCalcul(maxDistance);

  //number of clonotypes
  var numClonotypes = 8; //(if we want to have the number of clonotype : clonotypesName.length)
  //calculation of the width of the arcs according to the number of clonotypes
  var arcWidth = (chartRadius - arcPosition - numClonotypes * arcPadding) / numClonotypes;

//create a new arc generator
  var arc = d3.arc()
         .innerRadius(function(d, i){ return getInnerRadius(parseInt(distanceTable[i].index)); }) //set the inner radius to a specific value determine by a function
         .outerRadius(function(d, i){ return getOuterRadius(parseInt(distanceTable[i].index)); })
         .startAngle(function(d, i){ return scale(parseInt(distanceTable[i].start)); })	//determine the start angle for the arcs
         .endAngle(function(d){ return scale(d); });	//end angle of the cercle determine by the scale function

  //create radial axis to add text to identify the different axes
  var radialAxis = svg.append('g')
    .selectAll('g')
      .data(distanceTable)
      .enter().append('g');

  radialAxis.append('text')
    .style('font', '12px sans-serif')
    .attr('x', -45)
    .attr('y', function(d, i){ return (-getOuterRadius(i) + arcPadding); })
    .text(function(d,i){ return clonotypesName[i]; })
    .on("mousemove", function(d,i){displayOnTree(i,distanceTable);})
    .on("mouseout",hideOnTree);

  //create axial axis to identify the distances
  var axialAxis = svg.append('g')
    .selectAll('g')
      .data(ticks)
      .enter().append('g')
        .attr('transform', function(d) { return 'rotate(' + ((scale(d) * 180 / pi) - 90) + ')'; });

  //add line to the axial axis
  axialAxis.append('line')
    .style("stroke", "#cccccc")
    .style("stroke-width", "1px")
    .attr('x2', chartRadius);

  axialAxis.append('text')
    .attr('x', chartRadius + 10)
    .style('font', '12px sans-serif')
    .style('text-anchor', function (d) { return (scale(d) >= pi && scale(d) < 2 * pi ? 'end' : null); })
    .attr('transform', function (d) { return 'rotate(' + (90 - (scale(d) * 180 / pi)) + ',' + (chartRadius + 10) + ',0)'; })
    .text(function(d){ return d; });

  //data arcs
  var arcs = svg.append('g')
    .selectAll('path')
      .data(distanceTable)
      .enter().append('path')
      .style('fill', function(d, i) { return d.color; } )
      .style("stroke", function(d){ return d.stroke; })
        .style("stroke-dasharray", function(d){ return d.style; })
        .style("stroke-width", 0.75)

  arcs.transition()
    .duration(1)
    .attrTween('d', arcTween);

  arcs.on('mousemove', showTooltip)
  arcs.on('mouseout', hideTooltip)

  function arcTween(d, i) {
    var interpolate = d3.interpolate(0, d.length);
    return t => arc(interpolate(t), i);
  }

  function showTooltip(d) {
    tooltip.style("left", ((d3.event.pageX + 10)+"px"))
      .style("top", ((d3.event.pageY + 15)+"px"))
      .style('display', 'inline-block')
      .html(d.length-d.start);
    d3.select(this)
      .style("stroke", "black")
      .style("opacity", 0.8);
    clonotypesDistances.push(d["name"]);
    displayTree(dataClonotypes);
  }

  function hideTooltip() {
    tooltip.style('display', 'none');
    d3.select(this)
      .style("stroke", function(d){ return d.stroke; })
      .style("opacity", 1);
    hideOnTree();
  }

  //calculate the value of inner radius in function of the index of the clonotype
  function getInnerRadius(index) {
    return arcPosition + (numClonotypes - (index + 1)) * (arcWidth + arcPadding); //the position of the inner radius corresponds to the addition of distance from the center and the thickness of the other arcs according to the clonotype index
  }

  //calculate the value of outer radius in function of the index of the clonotype
  function getOuterRadius(index) {
    return getInnerRadius(index) + arcWidth; //the position of the outer radius correpond to the addition of the position of the inner radius and the tickness of the arc
  }
}

//browse the tree of clonotypes to find the 5 first clonotypes with the most abundance
function findMostAbundantClonotypes(node, table){
  var longestTreeBranch = [0,0,0], lengthBranch = [], nodeSize = [];
  //for each children of the given node 
  for(var i in node.children){
    //there is already 5 clonotypes stores in the tab
    if(table.length == 5){
      //Compare the abundance of the clonotypes to those in of the clonotypes in the tab
      comparisonOfAbundance(table, node.children[i]);
    }else{
      //add the clonotypes to the table
      table.push(node.children[i]);
      //sort the elment of the table depending on the abundance
      table.sort(function sortByAbondance(a, b){
        if (a.data.value < b.data.value){
          return -1;
        }else if (a.data.value > b.data.value){
          return 1;
        }
        return 0;
      });
      table.reverse();
    }

    //look among the children of this node if there are clonotypes with more abundance
    if(node.children[i].children){ 
      longestTreeBranch = findMostAbundantClonotypes(node.children[i], table);
      //add to a table all the length of the branch
      lengthBranch.push(longestTreeBranch[1]+parseFloat(node.children[i].data.length));
      nodeSize.push(longestTreeBranch[2]+(parseFloat(node.children[i].data.value)/100));
    }else{    
      //add to a table all the length of the branch
      lengthBranch.push(parseFloat(node.children[i].data.length));
      nodeSize.push(parseFloat(node.children[i].data.value)/100);
    }
  }

  longestTreeBranch[0] += 1;
  for(var j in lengthBranch){
    if(lengthBranch[j]+nodeSize[j]>longestTreeBranch[1]+longestTreeBranch[2]){
      longestTreeBranch[1]=lengthBranch[j];
      longestTreeBranch[2]=nodeSize[j];
    }
  }
  return longestTreeBranch;
}

//modify the table that store the most abundant clonotypes if clonotypewith a abundance superior is found
function comparisonOfAbundance(table, clonotype){
  var nbElement = table.length; 
  var superior = true;
  var indice = -1;
  //browse all the element of the table to find if the clonotype has an abondance superior to the other
  while( superior && (nbElement != 0)){
    if(parseFloat(clonotype.data.value)>table[nbElement-1].data.value){
      indice = nbElement-1; //store the position of the element 
    }else{
      superior=false;
    }
    nbElement--;
  }
  //modify the table if the clonotype have a abundance superior to the clonotype of the table
  if(indice!=-1){
    table.splice(indice, 0, clonotype); //add the clonotype to the table
    table.pop(); //delete the last element of the table
  }
}

//create an array which contain the five clonotpes with the most abundance to allow to draw the chart
function createDistanceTable(table, clonotypes){
  //browse the table containing the clonotype to represent
  for(var i in clonotypes){
    parentsLength = storeClonotypesAncestor(table, clonotypes[i], i, clonotypes[i].data.name);
  }
}

//browse all the parent of clonotype to add them to the array it is necessary to represent the distance
function storeClonotypesAncestor(table, clonotype, index, name){
  //browse in the parent of the clonotype
  if(clonotype.parent){
    parentsLength = storeClonotypesAncestor(table, clonotype.parent, index, name);
    //allow to know which name should be write on the graph
    if(name==clonotype.data["name"]){ appear=true; }else{ appear=false; }
    //cumulate the length of the parent to allow to draw the distances on the graph
    length = parseFloat(clonotype.data["length"])+parentsLength
    table.push({"name":clonotype.data["name"], "value":clonotype.data["value"], "length":length, "color":clonotype.data["color"], "index":index, "start":parentsLength, "stroke":clonotype.data["stroke"], "style":clonotype.data["style"]}); //add the clonotype to the table of clonotype
    return length;
  }else{
    return 0;
  }  
}


//********************** Sequence **************************************************************************

  function displaySequence(names){

    var user = "<?php echo $userFile; ?>",
        file = user +"_sequences_"+clone+".txt";
        path = "pipeline/usersFiles/"+user+"/tree/"+file;

    d3.text(path, function(error, data) {
      if (error) throw error;

      sequences = sequenceData(data);

      header = sequences.shift();

    //select the div element which will contain the sequences
    var table = document.getElementById('tableSequence');
    var thead = document.createElement('thead');

    table.appendChild(thead);

    var tr1 = document.createElement('tr');
    tr1.classList = "firstRow";
    thead.appendChild(tr1);
    var tr2 = document.createElement('tr');
    tr2.classList = "secondRow";
    thead.appendChild(tr2);
    var tr3 = document.createElement('tr');
    tr3.classList = "thirdRow";
    thead.appendChild(tr3);

    var th1 = document.createElement('th');
    var th2 = document.createElement('th');
    var th3 = document.createElement('th');

    th1.appendChild(document.createTextNode("Name"));
    th2.appendChild(document.createTextNode(""));
    th3.appendChild(document.createTextNode(header["name"]));

    tr1.appendChild(th1);
    tr2.appendChild(th2);
    tr3.appendChild(th3);

    var cpt = 1;

    cpt = headerInformation(tr1, tr2, tr3, cpt, header["V_region"], "Vregion", [Math.round(header["V_region"].length/2),Math.round(header["V_region"].length/2)], ["V"]);
    cpt = headerInformation(tr1, tr2, tr3, cpt, header["cdr3_region"], "cdr3region", [Math.round(header["cdr3_region"].length/2)-2,Math.round(header["cdr3_region"].length/2)+1], ["C","D","R","3"]);
    cpt = headerInformation(tr1, tr2, tr3, cpt, header["J_region"], "Jregion", [Math.round(header["J_region"].length/2),Math.round(header["J_region"].length/2)], ["J"]);


    //create a tbody element and add it to the table
    var tbody = document.createElement('tbody');
    table.appendChild(tbody);

    childClonotypeSequence(sequences,tbody, names);
    

    });

  }


  function headerInformation(tr1, tr2, tr3, cpt, column, className, nbr, regionName){
    for(var i in column){

      var th1 = document.createElement('th');
      var th2 = document.createElement('th');
      var th3 = document.createElement('th');

      if(i<nbr[0] || i>nbr[1]){th1.appendChild(document.createTextNode(""));}else{th1.appendChild(document.createTextNode(regionName.shift()));}

      if(cpt%10==0){th2.appendChild(document.createTextNode(cpt));}else{th1.appendChild(document.createTextNode(""));}

      th3.classList = className;
      th3.appendChild(document.createTextNode(column[i]));

      tr1.appendChild(th1);
      tr2.appendChild(th2);
      tr3.appendChild(th3);

      cpt+=1;
    }
    return cpt;
  }

  
  function sequenceData(data){
    var tableau = [];
    var seq = data.split("\n");
    for(var i in seq){
      var element = seq[i].split("	");
      tableau.push({"name":element[0],"V_region":element[1],"cdr3_region":element[2],"J_region":element[3]})
    }
    return tableau;
  }

    function childClonotypeSequence(data,table,clonotypesNames){
      //browse the clones and show the sequences for each of them
      for(var i in data){ 
        if(clonotypesNames.indexOf(data[i]["name"])!=-1){
          //create a tr element to add a line and add it to the table
          var tr = document.createElement('tr');
          table.appendChild(tr);
          //create a th element to add a cell that contain the name
          var td1 = document.createElement('td');
          td1.appendChild(document.createTextNode(data[i]["name"]));
          tr.appendChild(td1);
          for(var j in data[i]["V_region"]){
          //create a td element to add a cell that contain the sequence
          var td2 = document.createElement('td');
          td2.classList = "Vregion";
          td2.appendChild(document.createTextNode(data[i]["V_region"][j]));
          tr.appendChild(td2);}
          for(var j in data[i]["cdr3_region"]){
          //create a td element to add a cell that contain the sequence
          var td3 = document.createElement('td');
          td3.classList = "cdr3region";
          td3.appendChild(document.createTextNode(data[i]["cdr3_region"][j]));
          tr.appendChild(td3);}
          for(var j in data[i]["J_region"]){
          //create a td element to add a cell that contain the sequence
          var td4 = document.createElement('td');
          td4.classList = "Jregion";
          td4.appendChild(document.createTextNode(data[i]["J_region"][j]));
          tr.appendChild(td4);}
        }
      }
    }


    function collapse(d, depth){
      if(d.children){
        if(d.depth>=dpth){
          d._children = d.children;
          d._children.forEach(collapse);
          d.children = null;
        }else{
          d.children.forEach(collapse);
        }
      }
    }

    //give the start and end point to a branch    
    function branchShape(s,t) {
      return "M" + s.x + "," + s.y + "V" + t.y + "H" + t.x;
    }
 
    function axisStepCalcul(distance){
      var step;
      var axisStep = [];

      if(distance<0){
        step = 0.5;
      }else if(distance<=10){
        step = 1;
      }else{
        step = Math.round(distance/10);
      }

      for (var i = 0; i < distance; i += step) {
        axisStep.push(i);
      }
      axisStep.push(distance);
      return axisStep;
    }

    function firstClonotypes(file, cpt, names) {
      if(cpt<25 && file.length>0){
        var newfile = [], nbr_node = 0, size = 0;
        for(var i in file){
          for(var j in file[i].children){
            cpt ++;
            newfile.push(file[i].children[j]);
            names.push(file[i].children[j]["name"]);
          }
        }
        firstClonotypes(newfile, cpt, names);
      }else{
        for(var i in file){
          if(file[i].children){
            file[i]._children = file[i].children;
            file[i].children = null;
          }
        }  
      }
    }

    function displayOnTree(index,clonotypesTable){
      for(var i in clonotypesTable){
        if(index==parseInt(clonotypesTable[i]["index"])){
          clonotypesDistances.push(clonotypesTable[i]["name"]);
        }else if(index<parseInt(clonotypesTable[i]["index"])){
          break;
        }
      }
      displayTree(dataClonotypes);
    }
   
    function hideOnTree(){ clonotypesDistances.length=0;displayTree(dataClonotypes);}


  </script>
